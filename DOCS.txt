OVERVIEW

Nitrogen is a new web framework for Erlang. 
Nitrogen makes it faster and easier to develop event-driven web applications with AJAX in Erlang.



OVERVIEW OF A BASIC WEBPAGE
Each page is a module that exports two functions:

- A main/0 function.
- An event/1 function.

The page module must begin with the prefix "web_". This prefix is stripped off to get the name of the page.
So for example, the 'web_mypage' module would respond to http://mysite.com/mypage. (Slashes are converted to underscores, http://mysite.com/admin/start would use the module 'web_admin_start'.)

Upon an HTTP GET request, Nitrogen calls main/0. This function is responsible for returning a Yaws compatible response, such as {html, "Hello, world."}. In most cases, the main/0 function will use a combination of Elements and Actions (described below) to construct the page. 

Some elements on a page will initiate AJAX postbacks in the form of an HTTP POST. The post calls event/1. The sole argument is the postback tag of the event, described later.



ELEMENTS
Elements are the the building blocks to producing a page in Nitrogen. An element is just an Erlang record that is translated into HTML when fed through a render/1 function.

A simple example, wf:render(#span { text="Hello, world!" }) will render to "<span>Hello, world!</span>".
You can feed a list of elements into the render/1 function, and some elements can contain other elements, allowing you to build more complex HTML.

Every element has a basic list of properties:
- id - Set the name of an element. 
- actions - Add Actions to an element. Actions are described later.
- show_if - Set to true or false to show or hide the element.
- class - Set the CSS class of the element.
- style - Add CSS styling directly to the element.

Most elements have other properties that can be set as well to change their behavior.
You can see what these properties are by looking at the wf.inc include file, and at the modules that render the elments. (For example, the #span element is rendered in element_span.erl).



ACTIONS
Actions determine how a Nitrogen element will behave on the page. You can assign actions to any Nitrogen element, and just like Elements, some Actions can be nested.

Actions are assigned in two ways, either directly by setting a property of an Element, or indirectly with the wire function. 
For example:

#h1 { text="A Heading", actions=#effect_highlight{} }.

Or

#h1 { id=headline, text="A Heading" }
...
wf:wire(headline, #effect_highlight {})

Both of these code samples will produce an Headline 1 block of HTML with Scriptaculous's Effect.Highlight applied.



EVENTS
The #event Action is a special kind of Action, as it allows you to have an Element respond to Javascript events such as mouseover, mouseout, click, keypress, etc. Using #event, you can attach Javascript to an element that will run when the event is fired, or you can tell the page to initiate an AJAX postback.

Examples
The following line will pop up an alert box when the element is clicked:

#span { text="Hello, world!", actions=#event { type=click, actions="alert('Clicked!');" } }

The following line will execute an AJAX postback, calling validate_event/1 and then event/1 with the argument specified by the 'postback' property. This property can be set to any valid Erlang term:

#span { text="Hello, world!", actions=#event { type=click, postback=my_tag } }

See wf.inc for a list of actions, and look at the individual modules for more details. For example, the #effect_show action uses #action_effect_show {}.



VALIDATION
The #validate Action is another special type of Action. It allows you to attach validation to an element. The provided validators validate data on BOTH the client side (using LiveValidation) and the server side.

To add validation, use the wire command:
wf:wire(TriggerElement, TargetElement, #validate { validators=LIST OF VALIDATORS })
See wf.inc for a list of validators, and look at the individual modules for more detail. For example, the #is_required validator uses validate_is_required.erl.



GET AND POST ARGUMENTS
During a get request, you can access the value of get arguments using wf:q(arg_name_as_atom).
During a post request, you access the value of an element using wf:q(element_name_as_atom).



UPDATING WITH AJAX
To update an element during a postback, use one of the following:

wf:update(element_name_as_atom, NewTerms)
wf:insert_top(element_name_as_atom, NewTerms)
wf:insert_bottom(element_name_as_atom, NewTerms)



THE ELEMENT TREE
Multiple elements can have the same name. To differentiate, you can reference them using their path in the tree.
For example:
[Value1] = wf:q(parent1.child_control)
[Value2] = wf:q(parent2.child_control)

This part is untested, but in theory, you can use wf:q to pull back multiple values.
[Value1, Value2] = wf:q(child_control)



TEMPLATES

Use the #body element for a bare page, and use the #template tag to create a page template from an html file.
Read through element_template code to understand more.



USERS AND ROLES

There is support for users and roles.
Use wf:user() to get the current user and wf:user(User) to set the current user.
Likewise, use wf:role(Role) to see if the user is in a role, and wf:role(Role, Bool) to set whether the user is in a role.



CREATE YOUR OWN ELEMENTS

Because of Erlang's flexibility, you can easily add your own elements. Just define a record named after your element and include the ELEMENT_BASE attributes.

-record(myelement, {?ELEMENT_BASE, attr1, attr2, attr3 })

Then create a new module for the element, ie: 'element_myelement.erl'. See the existing elements for examples.

For some advance examples on how to have an element call back into a page, check out element_inplace_textbox and element_wizard.



CONTINUATIONS
Use wf:continue(Tag, FunctionToRun) to set up a continuation. This will start FunctionToRun, and then tell the web page to keep checking back until the function has completed.

Once the function has completed, it will call the continue/2 on your page, passing in the Tag and the Return Value.
